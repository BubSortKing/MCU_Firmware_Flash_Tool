
How to Calculate the key?
1、Negate
uint8_t seedInversion[4] = {0};
for(int i = 0; i < 4; i++)
{
	seedInversion[i] = ~seedfor27Serv[i];	//seedfor27Serv is seeds for 4Bytes
}

27 01：
k[0] = 0x00000011;
k[1] = 0x00000022;
k[2] = 0x00000033;
k[3] = 0x00000044;

27 03：
k[0] = 0x00000055;
k[1] = 0x00000066;
k[2] = 0x00000077;
k[3] = 0x00000088;

//seedfor27Serv[i] is seeds for 4Bytes；
v[0] = seedfor27Serv[0] << 24 | seedfor27Serv[1] << 16 | seedfor27Serv[2] << 8 | seedfor27Serv[3];
v[1] = seedInversion[0] << 24 | seedInversion[1] << 16 | seedInversion[2] << 8 | seedInversion[3];

//Then call this function
encipher(2, v, k);

v[0] v[1] v[2] v[3] //The result is final key



void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const k[4])
{
    unsigned int i;
    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;

    for(i=0; i<num_rounds; i++)
    {
        v0 += (((v1 << 4)^(v1 >> 5)) + v1) ^ (sum + k[sum & 3]);
        sum += delta;
        v1 += (((v0 << 4)^(v0 >> 5)) + v0) ^ (sum + k[(sum>>11) & 3]);
    }
    v[0]=v0, v[1]=v1;
}